。和QA sync，确定已有的内容和对我们新设计的API Testing的理解和反馈

JDoc

API Testing
1. 是什么？简要概括功能(10mins)
2. 为什么？当前痛点(30mins)
     应用API过多，单个API测试场景过多，测试用例的创建和维护复杂且成本较高。
     测试对环境造成脏数据，甚至影响下游系统造成脏数据 (需要判断哪些方法可以被重复触发，哪些不能)。
     针对单个服务级别的测试，无法屏蔽掉环境或其他外部系统的影响(微服务之间耦合关系)。

3. 怎么做？其他卖点()
     每个痛点对应的解决方案。
         针对痛点1:
         自动抓取收集测试用例，线上修改期望值的校验规则，降低用例的创建和维护成本。
         只测试使用频繁的api
         针对痛点2，3:
         启用Mock的调用模式。
     整个API生命周期，DEV和QA使用的泳道图。
     只测试那些真正被实际使用到的 API 调用，如果没有被使用到的，就不去测试。
     定义期望结果校验。
4. 具体实现的架构
     技术方案选型，及整体架构图
5. 具体界面简单展示
6. 使用这个工具后的DEV和QA的工作模式流程图
     DEV: 开发API，(API信息被收集)，在平台构造参数调用该API，调用信息被记录保存。下次其他后端开发想调用时可以直接使用这个调用参数体，前端人员和后端做集成时，可以参考该调用参数体，并执行调用做测试。
     QA: 思考设想在不同场景下，API的不同不同传参。
     定义对应api返回值的期望结果校验规则。
7. 关键技术的可行性分析。
     Mock编织：
     构造一个http server，挂载我们的javaagent。mock指定方法，调用api，获取入参，打印发送信息，获取返回值，打印发送信息。执行test case调用，在请求入口处分析请求头添加线程变量，后续mock方法入口判断线程变量，执行mock逻辑。
8. 当前进度与未来计划。
9. 提问

上送策略，百分比收集，特定请求头收集
接收策略

运行测试用例策略: mock，unmock

Mock方式:
Mock解决脏数据及环境问题：
实现: 通过Javaagent实现(byteman)。
添加自定义的mock注解，标注哪些方法属于对外部系统的子调用。进而在线上环境会收集该方法的入参和返回值。等之后回放时进行入参比对(比对MD5值也可以)及mock。因为不会对外部系统真实直接调用，所以有如下几个优点：
1. 不会产生脏数据。
2. 不受其他外部系统环境问题的影响。
3. 测试用例的执行速度会比较快。
Future Plan: 配置需要mock的第三方调用(db，http，redis，es...)，统一对db，redis，http api等外部调用进行拦截分析入参。

Unmock方式:
所有外部请求会真实发起调用，不会比对外部系统返回值。只会比对整个api调用的返回值。
